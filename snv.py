#!/usr/bin/python
import sys, os, getopt
import gzip, shutil, glob

# Copyright 2007, 2008, 2009
# Niko Beerenwinkel,
# Nicholas Eriksson,
# Moritz Gerstung,
# Lukas Geyrhofer,
# Osvaldo Zagordi,
# Kerensa McElroy,
# ETH Zurich

# This file is part of ShoRAH.
# ShoRAH is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# ShoRAH is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with ShoRAH.  If not, see <http://www.gnu.org/licenses/>.

'''


usage: snv.py -r reference -s sigma

------------
Output:
	a file of raw snvs, parsed from the directory support,
        and a directory containing snvs resulting from strand
        bias tests with different sigma values
------------
''' 
def segments(incr):
    """how many times is a window segment covered?
    """
    segCov={}
    try:
        file=open('coverage.txt')
    except IOError:
        sys.exit('Coverage file generated by b2w not found.')
    for f in file:
        w,c,b,e,v=f.rstrip().split('\t')
        b=int(b)
        segs=[c+str(b), c+str(b+incr),c+str(b+incr*2)]
        for i,s in enumerate(segs):
            if s in segCov:
                segCov[s][i]=1
            else:
                segCov[s]=[0,0,0]
                segCov[s][i]=1
    file.close()
    return segCov


 
def getRef(fasta):
    """Reference
    """
    f=open(fasta)
    line=f.readline()
    ref={}
    while line and line[0]=='>':
        head=line[1:].rstrip()
        seq=''
        line=f.readline()
        while line and line[0]!='>':
            seq+=line.rstrip()
            line=f.readline()
        ref[head]=seq.upper()
    f.close()
    return ref

def parseWindow(line,ref):
    """SNVs from support
    """
    ind={'A':'.0','T':'.1','G':'.2','C':'.3','a':'.0','t':'.1','g':'.2','c':'.3','-':'.4'}
    snp={}
    reads=0.0
    winFile, chrom, beg, end, cov = line.rstrip().split('\t')
    filename='w-%s-%s-%s.reads-support.fas.gz' % (chrom, beg, end)
    if os.path.exists('support/'+filename):
        window=gzip.open('support/'+filename)
    else:
        window=open(filename)
    b=int(beg)-1
    e=int(end)
    refSlice=ref[chrom][b:e]
    head=window.readline()
    seq=window.readline()
    while head and seq:
        post, av=head.rstrip().split(' ')
        post=float(post.split('=')[-1])
        av=float(av.split('=')[-1])
        if post>=0.9:
            reads+=av
            seq=seq.upper()
            pos=int(beg)
            for i,v in enumerate(refSlice):
                if v!=seq[i]:
                    id=float(str(pos)+ind[seq[i]])
                    if id in snp:
                        snp[id][4]+=av
                        snp[id][5]+=post*av
                    else:
                        snp[id]=[chrom,pos,v,seq[i],av,post*av]
                pos+=1
        head=window.readline()
        seq=window.readline()
    key=snp.keys()
    for k in key:
        snp[k][5]=snp[k][5]/float(snp[k][4])
        snp[k][4]=snp[k][4]/reads
    return snp

def getSNV(ref,segCov, incr):
    """Consensus from all windows
    """
    snpD={}
    try:
        file=open('coverage.txt')
    except IOError:
        sys.exit('Coverage file generated by b2w not found') 
    for f in file:
        snp=parseWindow(f,ref)
        beg=int(f.split('\t')[2])
        key=snp.keys()
        key.sort()
        for k in key:
             chrom,p,rf,var,av,post = snp[k]
             if k in snpD:
                 if p<(beg+incr):
                     snpD[k][4][2]=av
                     snpD[k][5][2]=post
                 elif p<(beg+incr*2):
                     snpD[k][4][1]=av
                     snpD[k][5][1]=post
                 else:
                     snpD[k][4][0]=av
                     snpD[k][5][0]=post
             else:
                 if p<(beg+incr):
                     cov=segCov[chrom+str(beg)]
                     if cov==[1,1,1]:
                         snpD[k]=[chrom, p, rf, var,['-','-',av],['-','-',post]]
                     elif cov==[1,0,0]:
                         snpD[k]=[chrom,p,rf,var,['*','*',av],['*','*',post]]
                     elif cov==[1,1,0]:
                         snpD[k]=[chrom,p,rf,var,['*','-',av],['*','-',post]]
                 elif p<(beg+incr*2):
                     cov=segCov[chrom+str(beg+incr)]
                     if cov==[1,1,1]:
                         snpD[k]=[chrom,p,rf,var,['-',av,'-'],['-',post,'-']]
                     elif cov==[1,1,0]:
                         snpD[k]=[chrom,p,rf,var,['*',av,'-'],['*',post,'-']]
                     elif cov==[0,1,1]:
                         snpD[k]=[chrom,p,rf,var,['-',av,'*'],['-',post,'*']]
                     elif cov==[0,1,0]:
                         snpD[k]=[chrom,p,rf,var,['*',av,'*'],['*',post,'*']]
                 else:
                     cov=segCov[chrom+str(beg+incr*2)]
                     if cov==[1,1,1]:
                         snpD[k]=[chrom,p,rf,var,[av,'-','-'],[post,'-','-']]
                     elif cov==[0,1,1]:
                         snpD[k]=[chrom,p,rf,var,[av,'-','*'],[post,'-','*']]
                     elif cov==[0,0,1]:
                         snpD[k]=[chrom,p,rf,var,[av,'*','*'],[post,'*','*']]
    return snpD

def printRaw(snpD):
    """Raw calls from shorah
    """
    key=snpD.keys()
    key.sort()
    out=open('raw_snv.txt','w')
    out1=open('SNV.txt','w')
    out.write('Chromosome\tPos\tRef\tVar\tFrq1\tFrq2\tFrq3\tPst1\tPst2\tPst3\n')
    out1.write('Chromosome\tPos\tRef\tVar\tFrq1\tFrq2\tFrq3\tPst1\tPst2\tPst3\n')
    for k in key:
        out.write(snpD[k][0]+'\t'+str(snpD[k][1])+'\t'+snpD[k][2]+'\t'+snpD[k][3])
        count=0
        for i in range(3):
            if type(snpD[k][4][i]) == float:
                freq='\t%.4f' % snpD[k][4][i]
                count+=1
            else:
                freq='\t'+snpD[k][4][i]
            out.write(freq)
        for i in range(3):
            if type(snpD[k][5][i]) == float:
                post='\t%.4f' % snpD[k][5][i]
            else:
                post='\t'+snpD[k][5][i]
            out.write(post)
        out.write('\n')
        if count >= 2:
            out1.write(snpD[k][0]+'\t'+str(snpD[k][1])+'\t'+snpD[k][2]+'\t'+snpD[k][3])
            for i in range(3):
                if type(snpD[k][4][i]) == float:
                    freq='\t%.4f' % snpD[k][4][i]
                else:
                    freq='\t'+snpD[k][4][i]
                out1.write(freq)
            for i in range(3):
                if type(snpD[k][5][i]) == float:
                    post='\t%.4f' % snpD[k][5][i]
                else:
                    post='\t'+snpD[k][5][i]
                out1.write(post)
            out1.write('\n')
    out.close()
    out1.close()


def filter(in_bam, sigma):

    """run strand bias filter
    """
    import subprocess
    dn = os.path.dirname(__file__)
    my_prog = os.path.join(dn, 'fil')
    print my_prog
    my_arg = ' -b '+in_bam+' -v '+str(sigma)
    retcode = subprocess.call(my_prog + my_arg, shell=True)
    return retcode 

def BH(p_vals,n):
    """performs BH procedure, returning q-vals'
    """
    q_vals=[]
    prev_bh=0
    for i, p in enumerate(p_vals):
        bh=p[0]*n/(i+1)
        bh=min(bh,1)
        bh=max(bh,prev_bh)
        pr_bh=bh
        q_vals.append((bh,p[1]))
    return q_vals

###########main code#########

def main(opts, args):
	''' new options parsing 
	usage:
	-h 
	-r reference 
        -b bam file
	-s sigma 
        -i incr
	'''
	
	usage = "usage: %s [-h -r reference -b bam -s sigma -i increment] " % os.path.basename(sys.argv[0])

	for o, a in opts:
		if o in ("-h", "--help"):
			print usage
			sys.exit()
		if o in ("-r"):
                        ref=a
                if o in ("-b"):
                        in_bam=a
		if o in ("-s"):
                        sig=float(a)
                if o in ("-i"):
                        incr=int(a)

        ref=getRef(ref)
        segCov=segments(incr) 

        if not os.path.isfile('snv/SNV.txt'):   
            snpD=getSNV(ref,segCov,incr)
            printRaw(snpD)            
        else:
            shutil.move('snv/SNV.txt', './')           

        #run filter
        retcode=filter(in_bam, sig)
        if retcode is not 0:
            sys.exit()

        snpFile=glob.glob('SNVs*.txt')[0]
        snvs=open(snpFile)
        write_list=[]
        p_vals=[]
        x=0
        for s in snvs:
            parts=s.rstrip().split('\t')
            p=parts[-1]
            p_vals.append((float(p),x))
            write_list.append(s.rstrip())
            x+=1
        p_vals.sort()
        q_vals=BH(p_vals,len(p_vals))
        snvs.close()
        snvs=open(snpFile,'w')
        snvs.write('Chromosome\tPos\tRef\tVar\tFrq1\tFrq2\tFrq3\tPst1\tPst2\tPst3\tFvar\tRvar\tFtot\tRtot\tPval\tQval\n')
        for q,i in q_vals:
            write_list[i]=(write_list[i]+('\t%.4f\n' % q),q)
        for l,q in write_list:
            if q>=0.05:
                snvs.write(l)
        snvs.close()

if __name__=="__main__":
    try:
        opts,args=getopt.getopt(sys.argv[1:], "hr:b:s:i:")
    except getopt.GetoptError:
        print usage
        sys.exit(2)
    main(opts, args)
